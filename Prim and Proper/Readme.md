# Puzzle
**Prim and Proper** https://www.codingame.com/contribute/view/123864bb2e846709e96de7223ac9b7f83141b1

# Goal
Using a linear congruential generator (LCG, https://en.wikipedia.org/wiki/Linear_congruential_generator) and the iterative randomized Prim's algorithm for maze generation (https://en.wikipedia.org/wiki/Maze_generation_algorithm), generate a maze and find the shortest path from (0, 0) in its top left corner to (width - 1, height - 1) in its bottom right corner.

The formula for the LCG looks like this: ```X(n + 1) = (a * X(n) + c) mod m``` and use only 32bit unsigned integers.

Use these constants for the LCG:
```
m = 48^5 - 1
a = 7 * 47 + 1
c = 100
```
With a seed of 1337, The first 10 random values should be:
```
   441310
145632400
155546304
114683053
134420474
 22866262
156551517
191599376
 36410364
 39633771
```

The Width and Height of the maze are the first two numbers generated by the LCG, respectively.  
Their values are clamped between 11 and 41 inclusive using (LCG() mod 31) + 11.  
The test seeds are all selected to ensure that width and height are odd.  

Use Prim's algorithm and the LCG to generate the maze.

See here: https://en.wikipedia.org/wiki/Maze_generation_algorithm (Iterative randomized Prim's algorithm (without stack, without sets))

Description of the maze generation algorithm:  
* Start with a Width X Height grid full of walls where . are passable and # are walls. Cells with even rows and columns are rooms, all other cells are considered walls.
* Mark the top left cell, (0, 0), as passable.  Add its walls (East and South in this first case) to the wall list.
* While there are walls in the list:
  * Pick a random wall W from the list using the LCG. Use LCG() mod wall_list_length as the index (add 1 if your list is not zero indexed). 
  * If only one of the cells that the wall divides is visited, then:
    * Make W passable and mark its unvisited neighbour N as	passable.
    * Add N's walls to the wall list (in North, East, South, West order).
  * Remove W from the wall list.

A seed of 9388 generates an 11 X 11 maze exactly like this:
```
.......#.#.
.#.#####.#.
.#.........
##.#.#.#.##
...#.#.#...
####.#####.
.#.....#.#.
.###.###.##
.........#.
.#.#.###.#.
.#.#.#.....
```

Now starting at (0, 0) int the top left corner find the shortest path to (width - 1, height - 1) in the bottom right corner.  
Then output the maze with the shortest path marked by *s. You can only move north, east, south, and west without leaving the edge of the maze. The priority for your moves should be in that order.  

The result for a seed of 9388 looks exactly like this:
```
***....#.#.
.#*#####.#.
.#***......
##.#*#.#.##
...#*#.#...
####*#####.
.#..*..#.#.
.###*###.##
....*****#.
.#.#.###*#.
.#.#.#..***
```

Now generate the correct maze and path for all the given seeds.  

# Input
* Unsigned 32-bit integer S: The LCG seed.

# Output
* Height lines: The final maze with the shortest path marked by *.

# Constraints
* 1 ≤ S ≤ 2^32, S is odd.
* 11 ≤ Width ≤ 41
* 11 ≤ Height ≤ 23
* Width X Height ≤ 1000
* Width & Height are always odd.
